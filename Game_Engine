# Pure game logic separated from any GUI so it can be unit-tested.
import random

GRID_SIZE = 4


class GameEngine:
    def __init__(self, grid_size: int = GRID_SIZE):
        self.grid_size = grid_size
        self.score = 0
        self.grid = [[0] * grid_size for _ in range(grid_size)]

    def start(self):
        self.score = 0
        self.grid = [[0] * self.grid_size for _ in range(self.grid_size)]
        self.spawn_tile()
        self.spawn_tile()

    def spawn_tile(self):
        empty = [(r, c) for r in range(self.grid_size) for c in range(self.grid_size) if self.grid[r][c] == 0]
        if not empty:
            return False
        r, c = random.choice(empty)
        self.grid[r][c] = 2 if random.random() < 0.9 else 4
        return True

    # Helpers
    @staticmethod
    def _compress(row):
        new_row = [v for v in row if v != 0]
        new_row += [0] * (len(row) - len(new_row))
        return new_row

    def _merge(self, row):
        for i in range(self.grid_size - 1):
            if row[i] != 0 and row[i] == row[i + 1]:
                row[i] *= 2
                row[i + 1] = 0
                self.score += row[i]
        return row

    # Moves return True if grid changed
    def move_left(self):
        changed = False
        new_grid = []
        for row in self.grid:
            compressed = self._compress(row[:])
            merged = self._merge(compressed)
            final = self._compress(merged)
            if final != row:
                changed = True
            new_grid.append(final)
        self.grid = new_grid
        return changed

    def move_right(self):
        self.grid = [list(reversed(row)) for row in self.grid]
        changed = self.move_left()
        self.grid = [list(reversed(row)) for row in self.grid]
        return changed

    def move_up(self):
        # transpose, move left, transpose back
        self.grid = [list(row) for row in zip(*self.grid)]
        changed = self.move_left()
        self.grid = [list(row) for row in zip(*self.grid)]
        return changed

    def move_down(self):
        self.grid = [list(row) for row in zip(*self.grid)]
        changed = self.move_right()
        self.grid = [list(row) for row in zip(*self.grid)]
        return changed

    def is_game_over(self):
        # empty cell => not over
        if any(0 in row for row in self.grid):
            return False
        # horizontal merges
        for r in range(self.grid_size):
            for c in range(self.grid_size - 1):
                if self.grid[r][c] == self.grid[r][c + 1]:
                    return False
        # vertical merges
        for c in range(self.grid_size):
            for r in range(self.grid_size - 1):
                if self.grid[r][c] == self.grid[r + 1][c]:
                    return False
        return True

    def check_win(self, goal=2048):
        return any(self.grid[r][c] >= goal for r in range(self.grid_size) for c in range(self.grid_size))
